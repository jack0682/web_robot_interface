/**
 * MQTT WebSocket ì„œë¹„ìŠ¤
 * ë°±ì—”ë“œ MQTT Processor (í¬íŠ¸ 8080)ì™€ ì‹¤ì‹œê°„ í†µì‹ 
 */
import { 
  MqttMessage, 
  WebSocketMessage, 
  TopicMessage, 
  MessageHandler,
  WebSocketConfig 
} from '../types/mqttTypes';

class MqttWebSocketService {
  private ws: WebSocket | null = null;
  private config: WebSocketConfig;
  private messageHandlers: Map<string, MessageHandler[]> = new Map();
  private subscriptions: Set<string> = new Set();
  private reconnectAttempts = 0;
  private reconnectTimeout: NodeJS.Timeout | null = null;
  private isConnected = false;
  private connectionListeners: ((connected: boolean) => void)[] = [];
  private messageQueue: any[] = [];

  constructor(config: WebSocketConfig) {
    this.config = config;
    this.connect();
  }

  /**
   * WebSocket ì—°ê²° ì„¤ì •
   */
  private connect() {
    try {
      if (this.ws) {
        this.ws.close();
      }

      console.log('ğŸ”Œ Connecting to MQTT WebSocket:', this.config.url);
      this.ws = new WebSocket(this.config.url);
      
      this.ws.onopen = this.handleOpen.bind(this);
      this.ws.onmessage = this.handleMessage.bind(this);
      this.ws.onerror = this.handleError.bind(this);
      this.ws.onclose = this.handleClose.bind(this);
      
    } catch (error) {
      console.error('âŒ WebSocket connection failed:', error);
      this.scheduleReconnect();
    }
  }

  /**
   * ì—°ê²° ì„±ê³µ í•¸ë“¤ëŸ¬
   */
  private handleOpen() {
    console.log('âœ… MQTT WebSocket connected');
    this.isConnected = true;
    this.reconnectAttempts = 0;
    
    // ì—°ê²° ë¦¬ìŠ¤ë„ˆ ì•Œë¦¼
    this.connectionListeners.forEach(listener => listener(true));
    
    // ì—°ê²° í™•ì¸ ë©”ì‹œì§€
    this.sendMessage({
      type: 'connection',
      clientId: `dashboard_${Date.now()}`,
      timestamp: new Date().toISOString()
    });

    // ê¸°ì¡´ êµ¬ë… ë³µì›
    this.subscriptions.forEach(topic => {
      this.sendMessage({
        type: 'subscribe',
        topic: topic
      });
    });

    // ëŒ€ê¸° ì¤‘ì¸ ë©”ì‹œì§€ ì „ì†¡
    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();
      this.sendMessage(message);
    }
  }

  /**
   * ë©”ì‹œì§€ ìˆ˜ì‹  í•¸ë“¤ëŸ¬
   */
  private handleMessage(event: MessageEvent) {
    try {
      const message: WebSocketMessage = JSON.parse(event.data);
      
      console.log('ğŸ“¨ MQTT message received:', {
        type: message.type,
        topic: message.topic,
        timestamp: message.timestamp
      });

      // íƒ€ì…ë³„ í•¸ë“¤ëŸ¬ ì‹¤í–‰
      const handlers = this.messageHandlers.get(message.type) || [];
      handlers.forEach(handler => {
        try {
          handler(message);
        } catch (error) {
          console.error(`âŒ Error in message handler for ${message.type}:`, error);
        }
      });

      // í† í”½ë³„ í•¸ë“¤ëŸ¬ ì‹¤í–‰
      if (message.topic) {
        const topicHandlers = this.messageHandlers.get(message.topic) || [];
        topicHandlers.forEach(handler => {
          try {
            handler(message);
          } catch (error) {
            console.error(`âŒ Error in topic handler for ${message.topic}:`, error);
          }
        });

        // ì™€ì¼ë“œì¹´ë“œ í† í”½ ì²˜ë¦¬ (robot/control/+)
        this.handleWildcardTopics(message);
      }

      // ì „ì²´ ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì‹¤í–‰
      const allHandlers = this.messageHandlers.get('*') || [];
      allHandlers.forEach(handler => {
        try {
          handler(message);
        } catch (error) {
          console.error('âŒ Error in universal message handler:', error);
        }
      });

    } catch (error) {
      console.error('âŒ Failed to parse WebSocket message:', error);
    }
  }

  /**
   * ì™€ì¼ë“œì¹´ë“œ í† í”½ ì²˜ë¦¬
   */
  private handleWildcardTopics(message: WebSocketMessage) {
    if (!message.topic) return;

    // robot/control/+ íŒ¨í„´ ë§¤ì¹­
    if (message.topic.startsWith('robot/control/')) {
      const wildcardHandlers = this.messageHandlers.get('robot/control/+') || [];
      wildcardHandlers.forEach(handler => handler(message));
    }

    // sensors/+ íŒ¨í„´ ë§¤ì¹­
    if (message.topic.startsWith('sensors/')) {
      const wildcardHandlers = this.messageHandlers.get('sensors/+') || [];
      wildcardHandlers.forEach(handler => handler(message));
    }
  }

  /**
   * ì—ëŸ¬ í•¸ë“¤ëŸ¬
   */
  private handleError(error: Event) {
    console.error('ğŸš¨ MQTT WebSocket error:', error);
    this.isConnected = false;
    this.connectionListeners.forEach(listener => listener(false));
  }

  /**
   * ì—°ê²° ì¢…ë£Œ í•¸ë“¤ëŸ¬
   */
  private handleClose(event: CloseEvent) {
    console.log('ğŸ”Œ MQTT WebSocket disconnected:', event.code, event.reason);
    this.isConnected = false;
    this.connectionListeners.forEach(listener => listener(false));
    
    // ì˜ˆìƒë˜ì§€ ì•Šì€ ì¢…ë£Œì¸ ê²½ìš° ì¬ì—°ê²°
    if (event.code !== 1000) {
      this.scheduleReconnect();
    }
  }

  /**
   * ì¬ì—°ê²° ìŠ¤ì¼€ì¤„ë§
   */
  private scheduleReconnect() {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }

    if (this.reconnectAttempts < this.config.maxReconnectAttempts) {
      const delay = Math.min(
        this.config.reconnectInterval * Math.pow(2, this.reconnectAttempts),
        30000
      );
      
      console.log(`ğŸ”„ Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts + 1})`);
      
      this.reconnectTimeout = setTimeout(() => {
        this.reconnectAttempts++;
        this.connect();
      }, delay);
    } else {
      console.error('ğŸš¨ Max reconnection attempts reached');
    }
  }

  /**
   * ë©”ì‹œì§€ ì „ì†¡
   */
  public sendMessage(message: any): boolean {
    const messageWithTimestamp = {
      ...message,
      timestamp: new Date().toISOString()
    };

    if (this.isConnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
      try {
        this.ws.send(JSON.stringify(messageWithTimestamp));
        return true;
      } catch (error) {
        console.error('âŒ Failed to send message:', error);
        return false;
      }
    } else {
      // ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš° íì— ì €ì¥
      this.messageQueue.push(messageWithTimestamp);
      console.warn('âš ï¸ Message queued (not connected):', message.type);
      return false;
    }
  }

  /**
   * í† í”½ êµ¬ë…
   */
  public subscribe(topic: string): void {
    this.subscriptions.add(topic);
    
    this.sendMessage({
      type: 'subscribe',
      topic: topic
    });
    
    console.log('ğŸ“¡ Subscribed to topic:', topic);
  }

  /**
   * í† í”½ êµ¬ë… í•´ì œ
   */
  public unsubscribe(topic: string): void {
    this.subscriptions.delete(topic);
    
    this.sendMessage({
      type: 'unsubscribe',
      topic: topic
    });
    
    console.log('ğŸ“¡ Unsubscribed from topic:', topic);
  }

  /**
   * ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ë“±ë¡
   */
  public onMessage<T = any>(topicOrType: string, handler: MessageHandler<T>): void {
    if (!this.messageHandlers.has(topicOrType)) {
      this.messageHandlers.set(topicOrType, []);
    }
    this.messageHandlers.get(topicOrType)!.push(handler);
  }

  /**
   * ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì œê±°
   */
  public offMessage<T = any>(topicOrType: string, handler: MessageHandler<T>): void {
    const handlers = this.messageHandlers.get(topicOrType);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  /**
   * ì—°ê²° ìƒíƒœ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
   */
  public onConnectionChange(listener: (connected: boolean) => void): void {
    this.connectionListeners.push(listener);
  }

  /**
   * ì—°ê²° ìƒíƒœ ë¦¬ìŠ¤ë„ˆ ì œê±°
   */
  public offConnectionChange(listener: (connected: boolean) => void): void {
    const index = this.connectionListeners.indexOf(listener);
    if (index > -1) {
      this.connectionListeners.splice(index, 1);
    }
  }

  /**
   * ìˆ˜ë™ ì¬ì—°ê²°
   */
  public reconnect(): void {
    this.reconnectAttempts = 0;
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }
    this.connect();
  }

  /**
   * ì—°ê²° ìƒíƒœ í™•ì¸
   */
  public getConnectionState(): boolean {
    return this.isConnected;
  }

  /**
   * êµ¬ë… ëª©ë¡ ì¡°íšŒ
   */
  public getSubscriptions(): string[] {
    return Array.from(this.subscriptions);
  }

  /**
   * ì„œë¹„ìŠ¤ ì¢…ë£Œ
   */
  public disconnect(): void {
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }
    
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect');
    }
    
    this.isConnected = false;
    this.subscriptions.clear();
    this.messageHandlers.clear();
    this.connectionListeners.length = 0;
    this.messageQueue.length = 0;
  }

  /**
   * í†µê³„ ì •ë³´
   */
  public getStats() {
    return {
      connected: this.isConnected,
      reconnectAttempts: this.reconnectAttempts,
      subscriptions: this.subscriptions.size,
      handlers: this.messageHandlers.size,
      queuedMessages: this.messageQueue.length,
      readyState: this.ws?.readyState || -1
    };
  }
}

export default MqttWebSocketService;
